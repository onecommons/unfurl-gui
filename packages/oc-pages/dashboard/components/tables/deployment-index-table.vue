<script>
import TableComponent from 'oc_vue_shared/components/oc/table.vue'
import {OcTab, EnvironmentSelection, LocalDeploy} from 'oc_vue_shared/components/oc'
import EnvironmentCell from '../cells/environment-cell.vue'
import ResourceCell from '../cells/resource-cell.vue'
import DeploymentControls from '../cells/deployment-controls.vue'
import DeploymentStatusIcon from '../cells/shared/deployment-status-icon.vue'
import LastDeploy from './deployment-index-table/last-deploy.vue'
import {GlTabs, GlModal, GlFormInput, GlFormGroup} from '@gitlab/ui'
import {mapGetters, mapActions, mapMutations} from 'vuex'
import {triggerIncrementalDeployment} from 'oc_vue_shared/client_utils/pipelines'
import { FLASH_TYPES } from 'oc_vue_shared/client_utils/oc-flash';
import Vue from 'vue'
import _ from 'lodash'
import * as routes from '../../router/constants'
import DashboardRouterLink from "../../components/dashboard-router-link.vue"
import MergeRequestsTable from './merge-requests-table.vue'



function deploymentGroupBy(item) {
    let result 
    try{
        result = `${item.deployment.name}:${item.application.name}:${item.environment.name}`
    } catch(e) { return }
    return result
}

const tabFilters = [
    {
        title: 'All'
    },
    {
        title: 'Running',
        filter(item) { return item.isDeployed }
    },
    {
        title: 'In Progress',
        filter(item) {
            return (
                !item.jobStatusIsUnsuccessful &&
                !item.isDeployed &&
                !item.isDraft &&
                !item.isUndeployed
            )
        }
    },
    {
        title: 'Drafts',
        filter(item) { return item.isDraft }
    },
    {
        title: 'Merge Requests',
        filter(item) { return false }
    },
    {
        title: 'Failed',
        filter(item) {
            return (
                item.jobStatusIsUnsuccessful &&
                !item.isDeployed &&
                !item.isDraft &&
                !item.isUndeployed
            )
        }
    },
    {
        title: 'Destroyed',
        filter(item) { return item.isUndeployed }
    }
]

export default {
    components: {
        TableComponent,
        EnvironmentCell,
        ResourceCell,
        DeploymentControls,
        LastDeploy,
        GlModal,
        GlTabs,
        OcTab,
        EnvironmentSelection,
        LocalDeploy,
        GlFormInput,
        GlFormGroup,
        DeploymentStatusIcon,
        DashboardRouterLink,
        MergeRequestsTable
    },
    props: {
        items: {
            type: Array,
            required: true
        },
        hideFilter: {
            type: Boolean,
            default: false
        },
        noMargin: {
            type: Boolean,
            default: false
        },
        noRouter: {
            type: Boolean,
            default: false
        },
        tabs: {
            type: Boolean,
            default: false
        }
    },
    data() {
        const glDark = document.querySelector('body.gl-dark') // not getting gl dark for some reason on this component
        const self = this
        const fields = [
            {key: 'deployment', groupBy: deploymentGroupBy, label: 'Deployment'},
            {
                key: 'environment',
                label: 'Environments',
                s: 'Environment',
                groupBy: (item) => item.environment?.name
            },
            {
                key: 'resource',
                label: 'Resources',
                textValue: (item) => item.resource?.title,
                groupBy: (item) => item.resource?.name,
                pluralize: (...args) => self.pluralizeResources(...args),
                s: 'Resource'
            },
            {
                key: 'last-deploy',
                label: 'Last Update',
                textValue: () => '',
            },
            {
                key: 'controls',
                label: 'Open',
                tableBodyStyles: {'justify-content': 'flex-end'},
                groupBy: (item) => item.context.deployment?.name,
                textValue: () => '',
            },
        ]

        const query = this.$route.query
        const show = query?.show
        let currentTab = tabFilters.findIndex(tab => tab.title.toLowerCase() == show?.toLowerCase())
        if(currentTab == -1) currentTab = 0

        const intent = '', target = null, newDeploymentTitle = null, cloneTargetEnvironment = null
        return {fields, routes, intent, target, transition: false, currentTab, newDeploymentTitle, cloneTargetEnvironment, glDark}

    },
    methods: {
        ...mapActions([
            'deleteDeployment',
            'deployInto',
            'undeployFrom',
            'cloneDeployment',
            'addUrlPoll',
            'renameDeployment',
            'createFlash'
        ]),
        ...mapMutations(['createError']),
        async deploy() {
            await this.deployInto(this.deploymentParameters)
            if(this.hasCriticalErrors) return
            const {deployment, environment} = this.target
            window.location.href = this.$router.resolve({
                name: routes.OC_DASHBOARD_DEPLOYMENTS, 
                params: {
                    name: deployment.name,
                    environment: environment.name
                },
                query: {
                  show: 'console'
                }
            }).href
        },
        async undeploy() {
            await this.undeployFrom(this.deploymentParameters)
            if(this.hasCriticalErrors) return
            const {deployment, environment} = this.target
            window.location.href = this.$router.resolve({
                name: routes.OC_DASHBOARD_DEPLOYMENTS, 
                params: {
                    name: deployment.name,
                    environment: environment.name
                },
                query: {
                  show: 'console'
                }
            }).href
        },
        statuses(scope) { return _.uniqBy(scope.item.context.deployment?.statuses || [], resource => resource?.status) },
        resumeEditingLink(scope) {
            const 
                application = scope.item.context.application,
                deployment = scope.item.context.deployment,
                environment = scope.item.context.environment,
                routerName = this.$router.name
            let to
            if(routerName == 'overview') {
                to =  {
                    name: 'deploymentDraftPage',
                    query: {
                        fn: deployment.title,
                    },
                    params: {
                        environment: environment.name,
                        slug: deployment.name
                    }
                }
                return {to}
            } else {
                to = `/${deployment.projectPath}/deployment-drafts/${environment.name}/${deployment.name}?fn=${deployment.title}`
                return to
            }
        },
        deploymentAttrs(scope) {
            const context = scope.item.context
            let href
            if(context.deployment?.__typename == 'DeploymentTemplate') href = this.resumeEditingLink(scope)
            else href = this.noRouter?
                `/dashboard/deployments/${context.environment.name}/${context.deployment.name}`: // TODO use from routes.js
                {name: routes.OC_DASHBOARD_DEPLOYMENTS, params: {name: context.deployment.name, environment: context.environment.name}}
            const result = typeof href == 'string'? {href}: {to: href}
            return result
        },
        async onModalConfirmed() {
            const intent = this.intent
            const {deployment, environment} = this.target

            await Vue.nextTick() // wait until modal is closed before doing anything

            switch(intent) {
                case 'rename':
                    if(deployment.title == this.newDeploymentTitle) return
                    await this.renameDeployment({deploymentName: deployment.name, environmentName: environment.name, newTitle: this.newDeploymentTitle})
                    if(! this.hasCriticalErrors) window.location.reload()
                    return
                case 'undeploy':
                    this.undeploy()
                    return
                case 'deploy':
                    this.deploy()
                    return
                case 'delete':
                    await this.deleteDeployment({deploymentName: deployment.name, environmentName: environment.name})
                    this.$router.replace({hash: '#_'})
                    this.handleDeleteRedirect()
                    return
                case 'clone':
                    const targetEnvironment = this.lookupEnvironment(this.cloneTargetEnvironment?.name)
                    this.createFlash({
                        message: `Cloning ${deployment?.title}...`,
                        type: FLASH_TYPES.SUCCESS,
                        duration: 5000
                    })
                    const clonedDeploymentName = await this.cloneDeployment({
                        deployment,
                        environment,
                        newDeploymentTitle: this.newDeploymentTitle,
                        targetEnvironment,
                    })
                    if(this.hasCriticalErrors) return
                    this.createFlash({
                        message: `Clone complete - redirecting`,
                        type: FLASH_TYPES.SUCCESS,
                        duration: 5000
                    })
                    const redirectLocation = `/${this.getHomeProjectPath}/-/deployments/${this.cloneTargetEnvironment?.name}/${clonedDeploymentName}`
                    window.location.href = redirectLocation
                    return
                case 'incRedeploy':
                    const deploymentItem = this.deploymentItemDirect({deployment, environment})
                    const variables = deploymentItem.pipeline.variables
                    const upstreamBranch = deploymentItem.pipeline.upstream_branch
                    const upstreamCommit = deploymentItem.pipeline.upstream_commit_id
                    const upstreamPipeline = deploymentItem.pipeline.upstream_pipeline_id
                    const upstreamProject = deploymentItem.pipeline.upstream_project_id
                    const result = await triggerIncrementalDeployment(
                        this.pipelinesPath,
                        {variables, upstreamBranch, upstreamCommit, upstreamPipeline, upstreamProject}
                    )
                    console.log(result)
                    return
                case 'edit':
                    window.location.href = sessionStorage['editing-target']
                    return
                default:
                    return

            }
        },
        onIntentToRename(deployment, environment) {
            this.intent = 'rename'
            this.target = {deployment, environment}
            this.newDeploymentTitle = deployment.title
        },
        onIntentToDelete(deployment, environment) {
            this.intent = 'delete'
            this.target = {deployment, environment}
        },
        onIntentToStop(deployment, environment) {
            this.intent = 'undeploy'
            this.target = {deployment, environment}
        },
        onIntentToStart(deployment, environment) {
            this.intent = 'deploy'
            this.target = {deployment, environment}
        },
        onIntentToClone(deployment, environment) {
            this.intent = 'clone'
            this.target = {deployment, environment}
            this.cloneTargetEnvironment = environment.name
            this.newDeploymentTitle = deployment.title
        },
        onIntentToLocalDeploy(deployment, environment) {
            this.intent = 'localDeploy'
            this.target = {deployment, environment}
        },
        onIntentToRedeploy(deployment, environment) {
            this.intent = 'incRedeploy'
            this.target = {deployment, environment}
        },
        onIntentToEdit(deployment, environment) {
            this.target = {deployment, environment}
            const deploymentItem = this.deploymentItemDirect({environment, deployment})
            if(deploymentItem?.isDraft) {
                window.location.href = sessionStorage['editing-target']
            } else {
                this.intent = 'edit'
            }
        },

        hasDeployPath(scope) {
            return !this.lookupDeployPath(scope.item.context.deployment?.name, scope.item.context.environment?.name)?.pipeline?.id
        },
        rowClass(item, type) {
            if (type !== 'row') return
            if(`#${item?.context?.deployment?.name}` == this.$route.hash) return 'highlight'
        },
        // TODO merge these
        deploymentItem(scope, method, ...args) {
            const environment = scope.item.context.environment
            const deployment = scope.item.context.deployment
            return this.deploymentItemDirect({deployment, environment}, method, ...args)
        },
        deploymentNameId(n) {
            return `deployment-${n}`
        },
        pluralizeResources(count, item) {
          if(count != 0) return
          const deploymentItem = this.deploymentItem({item})
          if(deploymentItem?.isDraft) return 'Not yet deployed' 
          //if(deploymentItem?.jobStatusIsUnsuccessful) return  ''
          return 'No resources'

        },
        handleDeleteRedirect() {
            if(this.$route.name == routes.OC_DASHBOARD_DEPLOYMENTS) {
                window.location.href = this.$router.resolve({name: routes.OC_DASHBOARD_DEPLOYMENTS_INDEX}).href
            } else {
                window.location.reload()
            }
        },
    },
    computed: {
        ...mapGetters([
            'pipelinesPath',
            'UNFURL_MOCK_DEPLOY',
            'lookupDeployPath',
            'lookupEnvironment',
            'getDeploymentDictionary',
            'getHomeProjectPath',
            'getCurrentNamespace',
            'getCurrentEnvironment',
            'getDeploymentTemplate',
            'deploymentItemDirect',
            'deleteDeploymentPreventedBy',
            'undeployPreventedBy',
            'hasCriticalErrors',
            'mergeRequests'
        ]),
        intentToDeletePreventedBy() {
            if(this.intent != 'delete') return []
            const {deployment, environment} = this.target
            return this.deleteDeploymentPreventedBy(deployment.name, environment.name)
        },
        ableToDelete() {
            return this.intent == 'delete' && this.intentToDeletePreventedBy.length == 0
        },
        intentToUndeployPreventedBy() {
            if(this.intent != 'undeploy') return []
            const {deployment, environment} = this.target
            return this.undeployPreventedBy(deployment.name, environment.name)
        },
        ableToUndeploy() {
            return this.intent == 'undeploy' && this.intentToUndeployPreventedBy.length == 0
        },
        projectPath() {
            const {deployment, environment} = this.target
            if(deployment.__typename == 'DeploymentTemplate') {
                return deployment.projectPath
            } else {
                const templateName = deployment.deploymentTemplate
                const template = this.getDeploymentDictionary(deployment.name, environment.name).DeploymentTemplate[templateName]
                return template?.projectPath
            }
        },
        deploymentParameters() {
            const {deployment, environment} = this.target
            const projectUrl = `${window.gon.gitlab_url}/${this.projectPath}.git`
            const deploymentBlueprint = deployment.__typename == 'DeploymentTemplate'?
                deployment.name : deployment.deploymentTemplate
            const mockDeploy = this.UNFURL_MOCK_DEPLOY
            return {
                projectUrl,
                deploymentBlueprint,
                deployPath: this.targetDeploymentDir,
                environmentName: environment.name,
                deploymentName: deployment.name,
                mockDeploy
            }
        },
        targetDeploymentDir() {
            if(!this.target) return ''
            const {environment, deployment} = this.target
            return `environments/${environment.name}/${this.projectPath}/${deployment.name}`
        },
        modal: {
            set(val) {
                if(!val) this.intent = ''
            },
            get() {
                return !!this.intent
            }
        },
        modalTitle() {
            const targetTitle = this.target?.deployment?.title || this.target?.deployment?.name
            switch(this.intent){
                case 'delete':
                    if(this.ableToDelete) {
                        return `Are you sure you want to delete ${targetTitle}?`
                    } else {
                        return `${targetTitle} can't be safely deleted yet.`
                    }
                case 'undeploy':
                    if(this.ableToUndeploy) {
                        return `Are you sure you want to teardown ${targetTitle}?` //It will not be deleted and you will be able to redeploy at any time.`
                    } else {
                        return `${targetTitle} can't be safely torn down yet.`
                    }
                case 'localDeploy':
                    return `Deploy ${targetTitle} locally with Unfurl`
                case 'incRedeploy':
                    return `Force an update of ${targetTitle}?`
                case 'edit':
                    return `Edit deployment '${targetTitle}'?`
                default:
                    return `${this.intent.toString().slice(0, 1)?.toUpperCase()}${this.intent.toString().slice(1)} ${targetTitle}?`
            }
        },
        useTabs() {
            return this.tabs && !this.noRouter
        },
        itemsSorted() {
            const self = this
            const result = [...this.items]
            result.sort((a,b) => {
                const diA = self.deploymentItem({item: a})
                const diB = self.deploymentItem({item: b})


                let createdAtA = diA?.createdAt || 0
                let createdAtB = diB?.createdAt || 0

                // sort as int, maintain position when missing
                if(createdAtA == 0) createdAtA = createdAtB - -1
                if(createdAtB == 0) createdAtB = createdAtA - -1

                return createdAtB - createdAtA

            })
            return result
        },
        itemsByTab() {
            if(!this.useTabs) return
            const result = []
            for(const tab of tabFilters) {
                const tabItems = []
                for(const item of this.itemsSorted) {
                    const deploymentItem = this.deploymentItem({item})
                    if(!deploymentItem) {
                        this.createError({message: `Deployment item not found for ${item?.deployment?.name}`, context: item, severity: 'major', issue: 'Unfurl GUI should not be considering these valid deployments'})
                        continue
                    }
                    if(!tab.filter || tab.filter(deploymentItem)) {
                        tabItems.push(item)
                    }
                }
                result.push(tabItems)
            }
            return result
        },
        countsByTab() {
            if(!this.useTabs) return
            let result = this.itemsByTab.map(list => {
                const counts = _.countBy(list, (item) => item.context.environment?.name + ':' + item.context.deployment?.name)
                return Object.keys(counts).length
            })
            result[tabFilters.findIndex(tf => tf.title == 'Merge Requests')] += this.mergeRequests.length
            result[tabFilters.findIndex(tf => tf.title == 'All')] += this.mergeRequests.length
            return result
        },
        tableItems() {
            if(this.useTabs) {
                return this.itemsByTab[this.currentTab]
            }
            return this.itemsSorted
        },
        deleteWarning() {
            return this.intent == 'delete' && this.deploymentItemDirect({deployment: this.target.deployment, environment: this.target.environment}, 'isDeployed')
        },
        provider() {
            return this.target?.environment?.primary_provider?.type ?? null
        },
        actionPrimary() {
            return {
                text: (this.intent == 'delete' && (this.deleteWarning || !this.ableToDelete)) ? 'Delete Anyway':
                    this.intent == 'undeploy' && !this.ableToUndeploy? 'Undeploy Anyway':
                    this.intent == 'localDeploy' ? 'OK': 'Confirm'
            }
        },
        actionCancel() {
            if(this.intent == 'localDeploy') return null
            return {text: 'Cancel'}
        },
        modalSize() {
            return this.intent == 'localDeploy'? 'lg': 'sm'
        },
        inferredLocalDeployIntent() {
            const matchingParams = this.$route.query?.show == 'local-deploy' && this.$route.params.name && this.$route.params.environment
            const loaded = this.getDeploymentTemplate?.name && this.getCurrentEnvironment?.name

            return matchingParams && loaded
        },
        showingMergeRequestsTab() {
            return this.currentTab == tabFilters.findIndex(tf => tf.title == 'Merge Requests')
        }
    },
    watch: {
        items: {
            immediate: true,
            handler(val) {
                for(const item of val) {
                    const deploymentItem = this.deploymentItemDirect({deployment: item.deployment, environment: item.environment})
                    if(deploymentItem?.isDeployed && item.deployment?.url) this.addUrlPoll({deployment: item.deployment, environment: item.environment})
                }
            }
        },
        currentTab(val) {
            const path = this.$route.path
            const show = val == 0? undefined : tabFilters[val]?.title?.toLowerCase()
            const query = {show}
            this.$router.replace({path, query})
        },
        inferredLocalDeployIntent: {
            immediate: true,
            handler(val) {
                if(val) {
                    this.onIntentToLocalDeploy(this.getDeploymentTemplate, this.getCurrentEnvironment)
                }
            }
        },
        modal(val) {
            if(!val && this.$route.query.show) {
                const newRoute = {...this.$route}
                newRoute.query = {...newRoute.query, show: undefined}

                this.$router.replace(newRoute)
            }
        }
    },
    async mounted() {
        const vm = this
        this.$refs.container.style.transition = 'none'
        this.transition = false
        this.$refs.container.style.transition = ''

        if(this.$route.hash) {
            setTimeout(
                () => {
                    vm.transition = true
                    let el = document.querySelector(`#${vm.deploymentNameId(vm.$route.hash.slice(1))}`)
                    if(el) {
                        el.scrollIntoView()
                    }
                },
                500
            )
        }
    },
    tabFilters
}
</script>
<template>
    <div ref="container" class="deployment-index-table" :class="{transition, 'gl-dark': glDark}">
        <gl-modal
            modalId="deployment-index-table"
            :title="modalTitle"
            v-model="modal"
            :size="modalSize"
            :actionPrimary="actionPrimary"
            :actionCancel="actionCancel"
            @primary="onModalConfirmed"
            >
            <div
                v-if="intent == 'delete' && !ableToDelete"
                class="m-3">
                <ol>
                    <li v-for="reason in intentToDeletePreventedBy" :key="reason" v-html="reason" />
                </ol>
            </div>
            <div 
                v-else-if="deleteWarning" 
                class="m-3"
                >
                <div style="color: red">
                    If you delete a deployment before <b>teardown</b>, you will not be able to stop the deployment via unfurl.cloud.
                </div>
                <div class="mt-2">
                    Please consider running teardown first if you have not already or reporting an issue as alternatives to deletion.
                </div>
            </div>
            <div 
                v-if="intent == 'undeploy' && !ableToUndeploy"
                class="m-3">
                <ol>
                    <li v-for="reason in intentToUndeployPreventedBy" :key="reason" v-html="reason" />
                </ol>
            </div>
            <div v-if="['clone', 'rename'].includes(intent)">
                <gl-form-group class="m-3" label="New deployment title">
                    <gl-form-input v-model="newDeploymentTitle"/>
                    <environment-selection 
                        v-if="intent == 'clone'"
                        class="mt-2"
                        v-model="cloneTargetEnvironment"
                        :provider="target.environment.primary_provider.type"
                    />
                </gl-form-group>
            </div>
            <div class="m-3" v-if="intent == 'edit'">
                <div v-if="deploymentItemDirect({deployment: target.deployment, environment: target.environment}, 'isUndeployed')">
                    <p>
                        <b>Warning</b>: Re-deploying after you've torn down a deployment is not supported
                    </p>
                </div>
                <div v-else-if="deploymentItemDirect({deployment: target.deployment, environment: target.environment}, 'isDeployed')">
                    <p>
                        Some resources may have already been created for <b>{{target.deployment.title}}</b>.
                    </p>
                    <p>
                        Updates to this deployment may be applied differently than expected.
                    </p>

                </div>
            </div>
            <div class="m-3" v-if="intent == 'localDeploy'">
                <local-deploy :environment="target.environment" :deployment="target.deployment" />
            </div>
        </gl-modal>
        <gl-tabs v-model="currentTab" v-if="useTabs">
            <oc-tab :titleCount="countsByTab[index]" :title="tab.title" :key="tab.title" v-for="(tab, index) in $options.tabFilters"/>
        </gl-tabs>
        <table-component v-show="!showingMergeRequestsTab" :noMargin="noMargin" :hideFilter="hideFilter" :useCollapseAll="false" :items="tableItems" :fields="fields" :row-class="rowClass">
            <template #deployment$head>
                <div class="ml-2" style="padding-left: 30px">
                    {{__('Deployment')}}
                </div>
            </template>
            <template #deployment="scope">
                <div class="d-flex">
                    <deployment-status-icon width="40px" :scope="scope" />
                    <div v-if="scope.item.context.application" style="display: flex; flex-direction: column;" :class="{'hash-fragment': `#${scope.item.context.deployment.name}` == $route.hash}">
                        <dashboard-router-link :noRouter="noRouter" :href="noRouter? deploymentItem(scope, 'viewableLink'): deploymentItem(scope, 'viewableTo')">
                            <b>{{scope.item.context.deployment.title}}:</b>
                        </dashboard-router-link>
                        <a :href="`/${scope.item.context.deployment.projectPath}`">
                            ({{scope.item.context.application.title}})
                        </a>

                    </div>
                </div>
            </template>
            <!--template #resource$empty="scope">
                <div v-if="hasDeployPath(scope)">{{__('Not yet deployed')}}</div>
            </template-->
            <template #resource="scope">
                <resource-cell v-if="scope.item.context.deployment" :noRouter="noRouter" :resource="scope.item.context.resource" :deployment="scope.item.context.deployment" :environment="scope.item.context.environment"/>
            </template>
            <template #environment="scope">
                <environment-cell :noRouter="noRouter" :environment="scope.item.context.environment"/>
            </template>
            <template #last-deploy$all="scope">
                <div v-if="scope.item._depth == 0" style="letter-spacing: -0.06em">
                    <last-deploy :deployment-item="deploymentItem(scope)" />
                </div>

            </template>

            <template #controls$head> <div></div> </template>
            <template #controls$all="scope">
                <deployment-controls @renameDeployment="onIntentToRename" @startDeployment="onIntentToStart" @stopDeployment="onIntentToStop" @deleteDeployment="onIntentToDelete" @cloneDeployment="onIntentToClone" @localDeploy="onIntentToLocalDeploy" @incRedeploy="onIntentToRedeploy" @edit="onIntentToEdit" v-if="scope.item._depth == 0" :scope="scope" />
            </template>

        </table-component>
        <p class="mt-5"/>
        <h3 v-if="tabs && currentTab == 0 && this.mergeRequests.length > 0">Open Merge Requests</h3>
        <merge-requests-table v-show="(tabs && currentTab == 0 && this.mergeRequests.length > 0) || showingMergeRequestsTab" />
    </div>

</template>
<style>
[id^="deployment-index-table"].modal-body { min-height: 0; padding: 0; }
</style>
<style scoped>

.deployment-index-table >>> .highlight {
    background-color: white;
    transition: background-color 0.5s;
}

.deployment-index-table.transition >>> .highlight {
    background-color: #FDFFE3;
}

.deployment-index-table.gl-dark >>> .highlight {
    background-color: black;
    transition: background-color 0.5s;
}

.deployment-index-table.gl-dark.transition >>> .highlight {
    background-color: #181A00;
}

.external-link-container >>> button {
    font-size: 1em;
    padding: 6px 9px;
    bottom: -2px
}
</style>
